#
# # make largest smallest
# E(g)$weight <- 1/(E(g)$weight/max(E(g)$weight))
#
# # for{
# # get shortest path, uses dijkstra for directed
# p <- shortest_paths(g, from = "Y_0", to = "Z", mode = "out")$vpath[[1]]
#
# # update weights
# p.weights <- E(g, path = p)$weight
# E(g, path = p)$weight <- p.weights + min(p.weights)
# E(g, path = p)$weight <- ifelse(E(g, path = p)$weight < 0, 0, E(g, path = p)$weight)
# # }
# \\\change this to  ?
# max_flow(g, source = "Y_0", target = "Z", )
# flow from source to target is an assignment of non-negative real numbers to the edges of the graph,
# satisfying two properties: (1) for each edge the flow (ie. the assigned number) is not more than the
# capacity of the edge (the capacity parameter or edge attribute), (2) for every vertex, except the source
# and the target the incoming flow is the same as the outgoing flow. The value of the flow is the incoming
# flow of the target vertex. The maximum flow is the flow of maximum value.
# I think this will act to reweight those tht cross over to the min
test.tmp <- test
test.tmp$capacity <- test.tmp$weight
g.tmp <- g
E(g.tmp)$capacity <- as.integer(E(g.tmp)$weight*1000)
mf <- max_flow(g.tmp, source = "Y_0", target = "Z")
E(g)$weight <- mf$flow/1000
# test.tmp$capacity=E(g)$weight
# this is basically ba slightly edited, bad version of the max flow algorithm
run <- 0
out_paths <- out_min_weight <- list()
out_remainder <- NULL
delete_this <- NULL
delete_this_too <- g
max_algo=2
# max_algo=1
# # take the mac flow and iterate down
# max_algo=2
# take the path with the smallest node and find the best path that goes through that node (does not account for ties)
# intermediate_gs <- list()
all_paths <- all_simple_paths(g, from = "Y_0", to = "Z")
if (max_algo == 1){
while (run <= length(all_paths)){
g.tmp <- g
# make largest smallest
E(g.tmp)$weight <- 1/(E(g.tmp)$weight) #/max(E(g)$weight))
p <- shortest_paths(g.tmp, from = "Y_0", to = "Z", mode = "out")$vpath[[1]]
p.weights <- E(g, path = p)$weight
# n.nodes <- length(p.weights)
p.weights <- p.weights #[-n.nodes]
if (!any(p.weights<=0)){
out_paths <- out_paths %>%
append(list(names(p)))
out_min_weight <- out_min_weight %>%
append(min(p.weights))
p.weights.delete <- E(delete_this_too, path = p)$weight
delete_this <- c(delete_this,
prod((p.weights.delete/14))
)
# update weights
E(g, path = p)$weight <- p.weights-min(p.weights)
E(g, path = p)$weight <- ifelse(E(g, path = p)$weight < 0, 0, E(g, path = p)$weight)
# print(E(g, path = p)$weight)
# intermediate_gs <- intermediate_gs %>%
#   append(g)
}else{
run <- run + 1
}
}}else if (max_algo == 2){
while (run <= length(all_paths)){
all_paths <- all_simple_paths(g.tmp, from = "Y_0", to = "Z")
# sorting like this will ensure that the path selected is that with the best route, however, neither this or the which.min(all_paths_weight) accounts for ties
all_paths_cost <- lapply(all_paths, function(p)
sum(E(g.tmp, path = p)$weight))
# sorting like this will ensure that the path selected is that with the best route, however, neither this or the which.min(all_paths_weight) accounts for ties
all_paths <- all_paths[order(unlist(all_paths_cost), decreasing = F)]
all_paths_weight <- lapply(all_paths, function(p) ifelse(
min(E(g.tmp, path = p)$weight)>0,
sum(E(g.tmp, path = p)$weight-min(E(g.tmp, path = p)$weight)),
NA
))
if (all(is.na(all_paths_weight))){
break
}else{
p <- all_paths[[which.min(all_paths_weight)]]
p.weights <- E(g.tmp, path = p)$weight
out_paths <- append(out_paths, list(names(p)))
out_min_weight <- append(out_min_weight, min(p.weights))
# update weights
E(g.tmp, path = p)$weight <- p.weights-min(p.weights)
run <- run + 1
}
}}
# }}else if (max_algo == 2){
#   while (run <= length(all_paths)){
#     all_paths <- all_simple_paths(g.tmp, from = "Y_0", to = "Z")
#     # if (max_algo == 3){
#     #   all_paths_weight <- lapply(all_paths, function(p) ifelse(
#     #     min(E(g.tmp, path = p)$weight)>0,
#     #     min(E(g.tmp, path = p)$weight),
#     #     NA
#     #   ))
#     # }else{
#     all_paths_weight <- lapply(all_paths, function(p) ifelse(
#       min(E(g.tmp, path = p)$weight)>0,
#       sum(E(g.tmp, path = p)$weight-min(E(g.tmp, path = p)$weight)),
#       NA
#     ))
#     # }
#     if (all(is.na(all_paths_weight))){
#       break
#     }else{
#       p <- all_paths[[which.min(all_paths_weight)]]
#       p.weights <- E(g.tmp, path = p)$weight
#
#       out_paths <- append(out_paths, list(names(p)))
#       out_min_weight <- append(out_min_weight, min(p.weights))
#
#       # update weights
#       E(g.tmp, path = p)$weight <- p.weights-min(p.weights)
#
#       run <- run + 1
#     }
#   }}
out_remainder <- g
# for (i in 1:length(out_paths)){
#   out_paths[[i]] <- names(out_paths[[i]])
# }
df_out <- cbind(freq = unlist(out_min_weight),
# delete_this = delete_this,
do.call(rbind.data.frame, out_paths))
df_out$freq <- round(df_out$freq/sum(df_out$freq), 2)
df_out$seq <- apply(df_out[,3:(ncol(df_out)-1)], 2, function(x) gsub("_.*", "", x)) %>%
as.data.frame() %>%
unite("Seq", sep = "")
# print(E(g)$weight)
# out_paths
# out_min_weight
if (max_algo==1){
data2 <- toVisNetworkData(g)
}else{
data2 <- toVisNetworkData(g.tmp)
}
data2$edges$label <- round(data2$edges$weight, 3)
data2$edges$value <- data2$edges$weight*5
data2$nodes$color.highlight.border <- "red"
n2 <- visNetwork(nodes = data2$nodes, edges = data2$edges) %>%
visEdges(arrows = "to") %>%
visPhysics(enabled = F) %>%
visInteraction(multiselect=T, selectable=T)
n2
# df_out$run <- "3"
# # a=df_out
# colnames(df_out) <- colnames(a)
# a=rbind(a, df_out)
View(df_out)
require(haplotypes)
data("dna.obj")
x<-dna.obj[1:6,,as.matrix=FALSE]
##Inferring haplotypes using 'Dna' object.
# coding gaps using simple indel coding method
h<-haplotype(x,indels="sic")
h
# giving DNA sequences of haplotypes
as.dna(h)
## Not run:
## Slots of an object Haplotype
h@haplist #haplotype list (names)
h@hapind #haplotype list (index)
h@uniquehapind #getting index of the first occurrence of haplotypes
h@sequence #DNA sequences of haplotypes
h@d #distance matrix of haplotypes
h@freq #haplotype frequencies
h@nhap #total number of haplotypes
## End(Not run)
## Inferring haplotypes using dist object.
d<-distance(x)
d<
d
h<-haplotype(d)
h
## Not run:
# returns an error message
as.dna(h)
require(haplotypes)
parsimnet(x,indels="s",prob=.95)
p <- parsimnet(x,indels="s",prob=.95)
plot(p)
x
istance(x)
distance(freq)
freq
freq[-c(1)]
x <- freq[-c(1)]
d <- freq[-c(1)]
h<-haplotype(d)
d<-as.matrix(distance(x))
d <- as.matrix(freq[-c(1)])
h<-haplotype(d)
h
p <- parsimnet(x,indels="s",prob=.95)
p <- parsimnet(as.matrix(freq[-c(1)]),indels="s",prob=.95)
h
data("dna.obj")
x<-dna.obj[1:6,,as.matrix=FALSE]
x
x$seq1
x@sequence
x<-dna.obj[1:6,,as.matrix=FALSE]
d<-as.matrix(distance(x))
h<-haplotype(d)
h
d<-as.matrix(distance(x@sequence))
install_github('philliplab/ViralHaplotyper')
devtools::install_github('philliplab/ViralHaplotyper')
library(ViralHaplotyper)
run_ViralHaplotyper_app()
library(ViralHaplotyper)
run_ViralHaplotyper_app()
require(tidyverse)
require(igraph)
require(visNetwork)
# dat <- tibble::tribble(
#   ~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`,~`11`,~`12`,
#   10,  "A",  "A",  "A",  "G",  NA,  NA,  NA,  NA,  NA,   NA,  NA,NA,
#   10,  NA,  NA,  NA,  "G",  "A",  "A",  NA,  NA,  NA,   NA, NA,NA,
#   10,  NA,  NA,  NA,  NA,  NA,  NA,  "A",  "C",  "–",   "G", NA,NA,
#   10,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA, "G", "G",
#
#   90,  "B",  "A",  "A",  "C",  NA,  NA,  NA,  NA,  NA,   NA,  NA,NA,
#   90,  NA,  NA,  NA,  "C",  "T",  "A",  NA,  NA,  NA,   NA, NA,NA,
#   90,  NA,  NA,  NA,  NA,  NA,  NA,  "A",  "C",  "A",   "G", NA,NA,
#   90,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA, "G", "D"
# )
# dat <- tibble::tribble(
#   ~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`,
#   10L,  "A",  "A",  "A",  "G",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
#   90L,  "B",  "A",  "A",  "C",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
#   17L,   NA,   NA,   NA,  "G",  "A",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
#   83L,   NA,   NA,   NA,  "C",  "T",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
#   30L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "–",   "G",    NA,    NA,
#   70L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "A",   "G",    NA,    NA,
#   50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "G",
#   50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "D"
# )
#
dat <- tibble::tribble(
~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`,
10L,  "A",  "A",  "A",  "G",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
17L,   NA,   NA,   NA,  "G",  "A",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
30L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "–",   "G",    NA,    NA,
90L,  "B",  "A",  "A",  "C",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
83L,   NA,   NA,   NA,  "C",  "T",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
70L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "A",   "G",    NA,    NA,
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "G",
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "D"
)
dat[dat == "N"] <- NA
dat
dat$`0` <- ifelse(is.na(dat$`1`), NA, "Y")
dat <- dat %>%
select(Count, `0`, everything())
freq <- data.frame(dat[c(1)])
for (c in 2:ncol(dat)){
d <- dat[,c(1, c)]
d.sum <- sum(d[complete.cases(d),]$Count)
d$Count[is.na(d[c(2)])] <- 0
d <- d$Count/d.sum
freq <- cbind(freq, d)
}
colnames(freq) <- colnames(dat)
freq
dat
pivot_longer(dat)
pivot_longer(dat, cols = Count)
dat %>%
pivot_longer(-Count, names_to = "income", values_to = "count")
dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt")
dat <- dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt")
dat
View(dat)
dat <- dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
complete.cases()
dat <- dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
filter(complete.cases())
require(tidyverse)
require(igraph)
require(visNetwork)
# dat <- tibble::tribble(
#   ~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`,~`11`,~`12`,
#   10,  "A",  "A",  "A",  "G",  NA,  NA,  NA,  NA,  NA,   NA,  NA,NA,
#   10,  NA,  NA,  NA,  "G",  "A",  "A",  NA,  NA,  NA,   NA, NA,NA,
#   10,  NA,  NA,  NA,  NA,  NA,  NA,  "A",  "C",  "–",   "G", NA,NA,
#   10,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA, "G", "G",
#
#   90,  "B",  "A",  "A",  "C",  NA,  NA,  NA,  NA,  NA,   NA,  NA,NA,
#   90,  NA,  NA,  NA,  "C",  "T",  "A",  NA,  NA,  NA,   NA, NA,NA,
#   90,  NA,  NA,  NA,  NA,  NA,  NA,  "A",  "C",  "A",   "G", NA,NA,
#   90,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA,  NA, "G", "D"
# )
# dat <- tibble::tribble(
#   ~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`,
#   10L,  "A",  "A",  "A",  "G",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
#   90L,  "B",  "A",  "A",  "C",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
#   17L,   NA,   NA,   NA,  "G",  "A",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
#   83L,   NA,   NA,   NA,  "C",  "T",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
#   30L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "–",   "G",    NA,    NA,
#   70L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "A",   "G",    NA,    NA,
#   50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "G",
#   50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "D"
# )
#
dat <- tibble::tribble(
~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`,
10L,  "A",  "A",  "A",  "G",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
17L,   NA,   NA,   NA,  "G",  "A",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
30L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "–",   "G",    NA,    NA,
90L,  "B",  "A",  "A",  "C",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
83L,   NA,   NA,   NA,  "C",  "T",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
70L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "A",   "G",    NA,    NA,
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "G",
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "D"
)
dat[dat == "N"] <- NA
dat
dat <- dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
filter(complete.cases())
View(dat)
dat <- tibble::tribble(
~Count, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`, ~`10`, ~`11`, ~`12`,
10L,  "A",  "A",  "A",  "G",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
17L,   NA,   NA,   NA,  "G",  "A",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
30L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "–",   "G",    NA,    NA,
90L,  "B",  "A",  "A",  "C",   NA,   NA,   NA,   NA,   NA,    NA,    NA,    NA,
83L,   NA,   NA,   NA,  "C",  "T",  "A",   NA,   NA,   NA,    NA,    NA,    NA,
70L,   NA,   NA,   NA,   NA,   NA,   NA,  "A",  "C",  "A",   "G",    NA,    NA,
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "G",
50L,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,    NA,   "G",   "D"
)
dat[dat == "N"] <- NA
dat
dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
filter(complete.cases())
dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
filter(complete.cases(.))
dat <- dat %>%
pivot_longer(-Count, names_to = "Pos", values_to = "nt") %>%
filter(complete.cases(.))
View(dat)
View(dat)
library(QSutils)
BiocManager::install("QSutils")
filepath<-system.file("extdata","ToyData_10_50_1000.fna", package="QSutils")
lst <- ReadAmplSeqs(filepath,type="DNA")
library(QSutils)
filepath<-system.file("extdata","ToyData_10_50_1000.fna", package="QSutils")
lst <- ReadAmplSeqs(filepath,type="DNA")
lst
SegSites(lst$hseqs)
lst$hseqs
SegSites(lst$hseqs)
length(lst$hseqs)
plot(HillProfile(lst$nr)
)
thr <- 0.1
sz1 <- 5000
sz2 <- 10000
qs.sample <- function(nr.pop,sz1,sz2){
div <- numeric(2)
nr.sz1 <- table(sample(length(nr.pop),size=sz1,replace=TRUE,p=nr.pop))
rare <- nr.sz1/sum(nr.sz1) < 0.01
div[1] <- sum(nr.sz1[rare])/sum(nr.sz1)
nr.sz2 <- table(sample(length(nr.pop),size=sz2,replace=TRUE,p=nr.pop))
rare <- nr.sz1/sum(nr.sz2) < 0.01
div[2] <- sum(nr.sz2[rare])/sum(nr.sz2)
div
}
hpl.sim <- replicate(2000,qs.sample(nr.pop,sz1,sz2))
nms <- paste(c(sz1,sz2))
set.seed(123)
n <- 2000
y <- geom.series(n,0.8)+geom.series(n,0.0002)
nr.pop <- round(y*1e7)
rare <- nr.pop/sum(nr.pop) < 0.01
RHL <- sum(nr.pop[rare])/sum(nr.pop)
round(RHL,4)
thr <- 0.1
sz1 <- 5000
sz2 <- 10000
qs.sample <- function(nr.pop,sz1,sz2){
div <- numeric(2)
nr.sz1 <- table(sample(length(nr.pop),size=sz1,replace=TRUE,p=nr.pop))
rare <- nr.sz1/sum(nr.sz1) < 0.01
div[1] <- sum(nr.sz1[rare])/sum(nr.sz1)
nr.sz2 <- table(sample(length(nr.pop),size=sz2,replace=TRUE,p=nr.pop))
rare <- nr.sz1/sum(nr.sz2) < 0.01
div[2] <- sum(nr.sz2[rare])/sum(nr.sz2)
div
}
hpl.sim <- replicate(2000,qs.sample(nr.pop,sz1,sz2))
nms <- paste(c(sz1,sz2))
boxplot(t(hpl.sim),names=nms,col="lavender",las=2,ylab="RHL")
abline(h=RHL,lty=4,col="navy")
# Load haplotype alignment with abundances.
filepath<-system.file("extdata","ToyData_10_50_1000.fna", package="QSutils")
lst <- ReadAmplSeqs(filepath,type="DNA")
SortByMutations(lst$hseq,lst$nr)
filepath<-system.file("extdata","Toy.GapsAndNs.fna", package="QSutils")
reads <- readDNAStringSet(filepath)
# Collapse this reads into haplotypes
lstCollapsed <- Collapse(reads)
reads
lstCollapsed
reads
# Collapse this reads into haplotypes
lstCollapsed <- Collapse(reads)
lstCollapsed
?CorrectGapsAndNs
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
phase_out <- py$var_df
install.packages("reticulate")
install.packages("reticulate")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
repl_python()
install.packages("reticulate")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
repl_python()
exit()
require(reticulate)
# use_python("/usr/local/opt/python/libexec/bin/python")
phase_out <- py$var_df
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
reticulate
require(reticulate)
?reticulate
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
library(reticulate)
os <- import("os")
os$listdir(".")
library(reticulate)
py_run_file("script.py")
py_help(os$chdir)
detach("package:reticulate", unload = TRUE)
require(reticulate)
# use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/bin/python3")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
source_python("flights.py")
flights <- read_flights("flights.csv")
require(reticulate)
use_python("/usr/local/bin/python3")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
install.packages("Rmarkdown")
install.packages("rmarkdown")
install.packages("rmarkdown")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
devtools::install_github("rstudio/reticulate")
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(stringr)
phase_out <- py$var_df
phase_out[phase_out == "NaN"] <- "N"
phase_out <- phase_out %>%
group_by_all() %>%
summarise(n = n())
require(tidyverse)
require(tidyverse)
phase_out <- py$var_df
phase_out[phase_out == "NaN"] <- "N"
phase_out <- phase_out %>%
group_by_all() %>%
summarise(n = n())
phase_out <- phase_out %>% unite("Seq", -n, remove = F, sep = '')
View(phase_out)
View(`*tmp*`)
View(phase_out)
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
require(stringr)
require(tidyverse)
phase_out <- py$var_df
View(phase_out)
