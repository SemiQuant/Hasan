```{r setup, include=FALSE, echo=TRUE}
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
```


```{python phase mutations}
import pysam
import numpy as np
from collections import Counter
vant = np.loadtxt("/Users/SemiQuant/Bioinformatics/Projects/Hasan/snps.tsv", delimiter="\t", 
          dtype={'names': ('CHROM', 'POS', 'REF', 'ALT', 'TYPE'),
          'formats': ('<U100', 'int', 'U10', 'U10', 'U10')}, skiprows=1)

# input file is the reference name, reference based positions and mutations and type

samfile = pysam.AlignmentFile("/Users/SemiQuant/Downloads/test/test.bam", "rb")

# TODO
# add in procedures for indels
# add in better output format, make it a matrix
# add in reference sequence so can determine more info later


# add in matching of paired reads 
# change this to the version in asap, think it was called pairwise reads
phase_out = []
for chrom in set(vant["CHROM"]):
    seq_out = []
    pos = vant["POS"][vant["CHROM"] == chrom]
    call = vant["ALT"][vant["CHROM"] == chrom]
    ref = vant["REF"][vant["CHROM"] == chrom]
    try:
        for read in samfile.fetch(chrom, until_eof=True):
            try:
                #convert to positions in the read
                pos_conv = read.query_alignment_start + read.get_reference_positions()[0] #unaligned leading bases + position of first alignment on reference
                pos_conv = pos - pos_conv
                phase = ""
                call_c = 0
                for p in pos_conv:
                    try:
                        # we dont want any bases that were filtered out so only take those that match the input
                        if read.query_sequence[p] in call[call_c].split(',') or read.query_sequence[p] == ref[call_c]: # in case more than on allele
                            phase += read.query_sequence[p]
                        elif read.is_proper_pair and read.is_read1:
                            pos = reads.tell()
                            try:
                                mate = reads.mate(read)
                            except ValueError:
                            # Invalid mate (usually post-filtered)
                                continue
                            finally:
                                if mate.query_sequence[p] in call[call_c].split(',') or mate.query_sequence[p] == ref[call_c]: # in case more than on allele
                                    phase += mate.query_sequence[p]
                                else:
                                    phase += "N"
                        else:
                            phase += "N"
                    except Exception:
                        phase += "N"
                    call_c += 1
                seq_out.append(phase)
            except Exception:
                continue
        # phase_out.append([[chrom], [Counter(seq_out)]])
        phase_out.append([[chrom], list(Counter(seq_out).items())])
    except Exception:
        print(chrom, " not found in bam file!")
```



```{r import and style matrix}
require(stringr)

phase_out <- py$phase_out
phase_out_df <- NULL
for (l in 1:length(phase_out)){
  phase_tmp <- do.call(rbind.data.frame, phase_out[[l]][[2]])
  phase_tmp$Chrom <- phase_out[[l]][[1]]
  colnames(phase_tmp) <- c("Seq", "Count", "Chrom")
}
# 
# split <- phase_tmp$Seq %>% 
#   str_split_fixed("", nchar(.))
# 
# phase_tmp <- phase_tmp[-c(1)]
# phase_tmp <- cbind(phase_tmp, split)
# phase_tmp[phase_tmp == "N"] <- NA

```


```{r get haplos}



for now, remove those with gaps in the middle
phase_tmp <- phase_tmp[!grepl("[AGCT]N[AGCT]", phase_tmp$Seq),]
phase_tmp <- phase_tmp[phase_tmp$Seq!="NNNN",]


# make into data frame
# append the chrom name then column number before the call in each cell
for (chr in unique(phase_tmp$Chrom)){
  dat <- phase_tmp %>% 
    filter(Chrom == chr) %>% 
    select(-Chrom)
  
  split_in <- dat$Seq %>%
    str_split_fixed("", nchar(.))
  
  dat <- cbind(dat[-c(1)], split_in)
  
  dat[dat == "N"] <- NA
  
  dat[-c(1)] <- apply(dat[-c(1)], 2, function(x) paste0(chr, "_", x))
  
  dat[-c(1)] <- apply(dat[-c(1)], 2, function(x) ifelse(grepl("_NA$", x), NA, x))
  if (chr == unique(phase_tmp$Chrom)[1]){
    dat_out <- dat
  }else{
    dat_out <- dat
    dat_out <- cbind(dat_out,
                     matrix(nrow = nrow(dat_out),
                            ncol = ncol(dat)-1))
    tmp_col <- ncol(dat)
    dat <- cbind(dat, 
                 matrix(nrow = nrow(dat),
                        ncol = ncol(dat_out)-ncol(dat))
    )
    dat <- dat[c(1, (tmp_col+1):ncol(dat), 2:tmp_col)]
    
    colnames(dat_out) <- colnames(dat) <- c("Count", 2:ncol(dat_out)-1)
    dat_out <- rbind(dat_out, dat)
    }
}

dat <- dat_out
# make ratios by read length
dat$grp <- "_"
for (r in 1:nrow(dat)){
  if (any(is.na(dat[r,]))){
    first_na <- min(which(is.na(dat[r,])))
    last_na <- max(which(is.na(dat[r,])))
    dat[r,"grp"] <- paste0(first_na, "_", last_na)
  }else{
    dat[r,"grp"] <- paste0(ncol(dat), "_", ncol(dat))
  }
}

dat <- dat %>%
  group_by(grp) %>%
  mutate(Count = Count/sum(Count)) %>%
  ungroup()

dat <- dat %>%
  select(-grp)

# sort by frequency, and then each columns first non-NA
# dat %>%
#   arrange(desc("Count"))
for (r in 1:nrow(dat)){
  if (any(is.na(dat[r,]))){
    dat[r,"grp"] <- min(which(!is.na(dat[r,-1])))
  }else{
    dat[r,"grp"] <- ncol(dat)
  }
}
dat <- dat[order(1/dat$grp, dat$Count, decreasing = T),]

dat <- dat[,-ncol(dat)]







```

