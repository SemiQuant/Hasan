```{r setup, include=FALSE, echo=TRUE}
require(reticulate)
use_python("/usr/local/opt/python/libexec/bin/python")
```


```{python phase mutations, include=FALSE}
import pysam
from collections import Counter
import pandas as pd
samfile = pysam.AlignmentFile("/Users/SemiQuant/Downloads/BDQ_haplo/TB-B240-054_S26-bowtie2.bam", "rb")

# var_dic will be snps/indels, if also adding reference then edit the below
# import numpy as np
# vant = np.loadtxt("/Users/SemiQuant/Bioinformatics/Projects/Hasan/snps.tsv", delimiter="\t", 
#           dtype={'names': ('CHROM', 'POS', 'REF', 'ALT', 'TYPE'),
#           'formats': ('<U100', 'int', 'U10', 'U10', 'U10')}, skiprows=1)
var_dic = {}
# this is gross, but i dont really speak python 
with open("/Users/SemiQuant/Bioinformatics/Projects/Hasan/snps.tsv") as f:
    next(f) # skip header line
    for line in f:
        (CHROM, POS, REF, ALT, TYPE) = line.split()
        try:
            var_dic[CHROM][int(POS)].setdefault('call', []).append(ALT)
        except:
            try:
                var_dic[CHROM][int(POS)] = {'call' : [ALT]}
            except:
                var_dic[CHROM] = {int(POS) : {'call' : [ALT]}}

# var_dic={'rpoC': {1221: {'call': ['T']}}, 'Rv0678_amplicon4': {111: {'call': ['A', 'G', 'G', 'T']}, 112: {'call': ['G', '-']}, 114: {'call': ['C']}, 116: {'call': ['C']}}}var_dic={'rpoC': {1221: {'call': ['T']}}, 'Rv0678_amplicon4': {111: {'call': ['A', 'G', 'G', 'T']}, 112: {'call': ['G', '-']}, 114: {'call': ['C']}, 116: {'call': ['C']}}}

# this is like this as I dont really know pysam and how to do it cleaner, with also getting readnames
for chrom in var_dic:
    if chrom not in samfile.references:
        print(chrom, " not found in bam file!")
    else:
        for i in var_dic[chrom]:
            for pileupcolumn in samfile.pileup(chrom, i, i+1):
                for pileupread in pileupcolumn.pileups:
                    if pileupread.query_position == i:
                        if not pileupread.is_del: # if reference then add
                            read_call_tmp = pileupread.alignment.query_sequence[pileupread.query_position]
                            try:
                                #  check if it matches the call in there as pairs have same name
                                if read_call_tmp == var_dic[chrom][i][pileupread.alignment.query_name]:
                                    break
                                else:
                                    var_dic[chrom][i][pileupread.alignment.query_name] = "N"
                            except:
                                if pileupread.is_refskip == 0: # if reference then add, not sure if this is working
                                    var_dic[chrom][i][pileupread.alignment.query_name] = read_call_tmp
                                elif read_call_tmp in var_dic[chrom][i]["call"]:
                                    var_dic[chrom][i][pileupread.alignment.query_name] = read_call_tmp
                                else:
                                    var_dic[chrom][i][pileupread.alignment.query_name] = "N"
                        else:
                            try:
                                #  check if it matches the call in there as pairs have same name
                                if read_call_tmp == var_dic[chrom][i][pileupread.alignment.query_name]:
                                    break
                                else:
                                    var_dic[chrom][i][pileupread.alignment.query_name] = "N"
                            except:
                                if read_call_tmp == var_dic[chrom][i][pileupread.alignment.query_name]:
                                    break
                                else:
                                    var_dic[chrom][i][pileupread.alignment.query_name] = "-"

# var_df = pd.DataFrame.from_dict(var_dic)
# var_df.reset_index(drop=True, inplace=True)
# var_df = var_df[1:]
var_df = pd.DataFrame.from_dict({(i,j): var_dic[i][j] 
                           for i in var_dic.keys() 
                           for j in var_dic[i].keys()},
                       orient='columns')
var_df = var_df[1:]
```



```{r import and style matrix}
require(stringr)
require(tidyverse)
phase_out <- py$var_df
phase_out[phase_out == "NaN"] <- "N"
phase_out <- phase_out %>% 
  group_by_all() %>% 
  summarise(n = n())
phase_out <- phase_out %>% unite("Seq", -n, remove = F, sep = '')
```


```{r get haplos}
phase_tmp <- phase_out
phase_tmp$Seq <- 

for now, remove those with gaps in the middle
phase_tmp <- phase_tmp[!grepl("[AGCT-]N[AGCT-]", phase_tmp$Seq),]
phase_tmp <- phase_tmp[phase_tmp$Seq!="NNNN",]


# make into data frame
# append the chrom name then column number before the call in each cell
for (chr in unique(phase_tmp$Chrom)){
  dat <- phase_tmp %>% 
    filter(Chrom == chr) %>% 
    select(-Chrom)
  
  split_in <- dat$Seq %>%
    str_split_fixed("", nchar(.))
  
  dat <- cbind(dat[-c(1)], split_in)
  
  dat[dat == "N"] <- NA
  
  dat[-c(1)] <- apply(dat[-c(1)], 2, function(x) paste0(chr, "_", x))
  
  dat[-c(1)] <- apply(dat[-c(1)], 2, function(x) ifelse(grepl("_NA$", x), NA, x))
  if (chr == unique(phase_tmp$Chrom)[1]){
    dat_out <- dat
  }else{
    dat_out <- dat
    dat_out <- cbind(dat_out,
                     matrix(nrow = nrow(dat_out),
                            ncol = ncol(dat)-1))
    tmp_col <- ncol(dat)
    dat <- cbind(dat, 
                 matrix(nrow = nrow(dat),
                        ncol = ncol(dat_out)-ncol(dat))
    )
    dat <- dat[c(1, (tmp_col+1):ncol(dat), 2:tmp_col)]
    
    colnames(dat_out) <- colnames(dat) <- c("Count", 2:ncol(dat_out)-1)
    dat_out <- rbind(dat_out, dat)
    }
}

dat <- dat_out
# make ratios by read length
dat$grp <- "_"
for (r in 1:nrow(dat)){
  if (any(is.na(dat[r,]))){
    first_na <- min(which(is.na(dat[r,])))
    last_na <- max(which(is.na(dat[r,])))
    dat[r,"grp"] <- paste0(first_na, "_", last_na)
  }else{
    dat[r,"grp"] <- paste0(ncol(dat), "_", ncol(dat))
  }
}

dat <- dat %>%
  group_by(grp) %>%
  mutate(Count = Count/sum(Count)) %>%
  ungroup()

dat <- dat %>%
  select(-grp)

# sort by frequency, and then each columns first non-NA
# dat %>%
#   arrange(desc("Count"))
for (r in 1:nrow(dat)){
  if (any(is.na(dat[r,]))){
    dat[r,"grp"] <- min(which(!is.na(dat[r,-1])))
  }else{
    dat[r,"grp"] <- ncol(dat)
  }
}
dat <- dat[order(1/dat$grp, dat$Count, decreasing = T),]

dat <- dat[,-ncol(dat)]







```

